# Historia de Usuario: Pruebas automáticas de integración y unitarias con alta cobertura

**ID:** HU-002  
**Rol:** Desarrollador de la clínica  
**Necesidad:** Implementar pruebas automáticas de integración y unitarias para el API de gestión de pacientes  
**Propósito:** Garantizar la calidad, robustez y mantenibilidad del sistema, asegurando una cobertura de código superior al 80%

## Criterios de Aceptación
- Se deben implementar pruebas unitarias para todos los componentes críticos del API, cubriendo casos positivos y negativos.
- Se deben implementar pruebas de integración que validen el correcto funcionamiento de los flujos principales (CRUD, exportación, consumo de servicios externos, mensajería, manejo de errores).
- La cobertura de código (code coverage) debe ser superior al 80% en líneas, ramas y métodos; mientras más alta, mejor.
- La cobertura debe ser validada localmente usando herramientas como SonarLint y plugins de coverage.
- Las pruebas deben ejecutarse automáticamente como parte del ciclo de desarrollo local.
- Las pruebas deben validar tanto escenarios exitosos como fallos técnicos y de negocio.
- El reporte de cobertura debe estar disponible para consulta del equipo.

## Restricciones
- No se debe bajar la cobertura por debajo del 80% sin justificación y aprobación del equipo.
- No se deben omitir pruebas de casos de error o flujos alternos.
- No se debe depender de herramientas externas a la máquina local para validar la cobertura (no Jenkins, no Azure DevOps, no SonarCloud).

## Notas
- Se recomienda utilizar frameworks como JUnit, Mockito, y herramientas de cobertura como JaCoCo.
- La cobertura debe ser revisada y mejorada de forma continua.
- El objetivo es maximizar la cobertura sin sacrificar la calidad de las pruebas.
- El reporte de cobertura debe ser comprensible y accesible para todo el equipo.

---

## Análisis y Diseño Arquitectónico (Arquitecto)

### 1. Contexto General
La historia 002 exige pruebas automáticas unitarias e integración con cobertura superior al 80%, asegurando calidad, robustez y mantenibilidad en todos los componentes del sistema.

### 2. Componentes y Alcance de Pruebas
- **Pruebas Unitarias**: Para servicios, controladores, utilidades y lógica de negocio. Uso de JUnit 5 y Mockito.
- **Pruebas de Integración**: Para flujos completos (CRUD, exportación, mensajería, consumo de APIs externas). Uso de Testcontainers para PostgreSQL y RabbitMQ.
- **Cobertura**: Validada con JaCoCo y SonarLint localmente. Se exige cobertura >80% en líneas, ramas y métodos.
- **Reporte**: Generación automática y accesible para el equipo.

### 3. Diseño de Estrategia de Pruebas
- Seguir los estándares definidos en `docs/architecture/coding-standards.md`.
- Mockear dependencias externas en unitarias (DB, MQ, WebClient, POI).
- Pruebas de integración deben usar recursos reales (contenedores) y validar escenarios exitosos y de error.
- Incluir pruebas para manejo de errores técnicos y de negocio (onErrorResume, onErrorReturn, ControllerAdvice).
- Validar logs y métricas en pruebas de integración.

### 4. Decisiones Arquitectónicas
- **Cobertura mínima**: No permitir bajar de 80% sin justificación y aprobación.
- **Automatización local**: No depender de pipelines externos; todo debe ejecutarse y validarse en la máquina del desarrollador.
- **Revisión continua**: Mejorar cobertura y calidad de pruebas de forma incremental.
- **Documentación**: Mantener actualizado el reporte de cobertura y los casos de prueba relevantes.

### 5. Riesgos y Mitigaciones
- **Falsos positivos/negativos**: Revisar mocks y escenarios de integración.
- **Cobertura superficial**: Revisar que las pruebas validen lógica real, no solo líneas ejecutadas.
- **Ambientes inconsistentes**: Usar Testcontainers para entornos reproducibles.

### 6. Referencias
- [coding-standards.md](../architecture/coding-standards.md)
- [flujo-registro-paciente.md](../architecture/flujo-registro-paciente.md)
- [flujo-exportacion-excel.md](../architecture/flujo-exportacion-excel.md)
- [flujo-consulta-clima.md](../architecture/flujo-consulta-clima.md)

---

## Refinamiento Técnico (Scrum Master)

### 1. Descomposición Técnica y Tareas
- Identificar todos los componentes críticos a cubrir con pruebas unitarias (servicios, controladores, utilidades, validaciones).
- Implementar pruebas unitarias usando JUnit 5 y Mockito, cubriendo casos positivos y negativos.
- Implementar pruebas de integración usando Testcontainers para PostgreSQL y RabbitMQ.
- Validar flujos completos: CRUD, exportación a Excel, mensajería, consumo de APIs externas, manejo de errores.
- Mockear dependencias externas en pruebas unitarias (DB, MQ, WebClient, POI).
- Incluir pruebas para onErrorResume, onErrorReturn y ControllerAdvice.
- Generar y revisar reporte de cobertura con JaCoCo y SonarLint localmente.
- Documentar y mantener actualizado el reporte de cobertura y casos de prueba.
- Revisar y mejorar cobertura de forma incremental hasta superar el 80%.

### 2. Checklist de Refinamiento
- [ ] Componentes críticos identificados
- [ ] Pruebas unitarias implementadas y ejecutadas
- [ ] Pruebas de integración implementadas y ejecutadas
- [ ] Mocking de dependencias externas realizado
- [ ] Pruebas de manejo de errores incluidas
- [ ] Reporte de cobertura generado y revisado
- [ ] Cobertura superior al 80% validada
- [ ] Documentación de pruebas y cobertura actualizada

### 3. Análisis de Riesgos Técnicos
- Cobertura superficial (pruebas que no validan lógica real)
- Falsos positivos/negativos por mocks mal configurados
- Ambientes inconsistentes para integración (solucionar con Testcontainers)
- Omisión de pruebas para flujos de error o alternos
- Reportes de cobertura desactualizados

### 4. Contexto Técnico Complementario
- Seguir los estándares de `docs/architecture/coding-standards.md`.
- Validar cobertura en líneas, ramas y métodos.
- Mantener reporte de cobertura accesible para el equipo.
- Mejorar cobertura y calidad de pruebas de forma continua.

---

## Estimación (Scrum Master)

### Estimación en Story Points
**8 puntos** (historia de pruebas y cobertura, requiere esfuerzo técnico y validación continua)

### Justificación de la Estimación
- Incluye diseño e implementación de pruebas unitarias y de integración para todos los componentes críticos.
- Requiere configuración de herramientas de cobertura (JaCoCo, SonarLint) y generación de reportes.
- Implica validación de cobertura >80% en líneas, ramas y métodos.
- Involucra riesgos por ambientes de integración, mocks y cobertura superficial.

### Análisis de Complejidad
- **Tecnológica:** Media-Alta (JUnit 5, Mockito, Testcontainers, JaCoCo)
- **Integración:** Media (pruebas de flujos completos, recursos reales)
- **Pruebas:** Alta (casos positivos, negativos, errores técnicos y de negocio)
- **Documentación:** Media (reporte de cobertura, documentación de pruebas)

### Identificación de Riesgos
- Cobertura insuficiente o superficial
- Falsos positivos/negativos por mocks mal configurados
- Ambientes inconsistentes para integración
- Omisión de pruebas para flujos de error o alternos
- Reportes de cobertura desactualizados

---

**Estado:** Estimado (SM)
