# Historia de Usuario: Gestión de pacientes clínica (API reactiva)

**ID:** HU-001  
**Rol:** Desarrollador de la clínica  
**Necesidad:** Crear un API reactivo para gestionar pacientes usando una base de datos relacional PostgreSQL y R2DBC  
**Propósito:** Garantizar operaciones eficientes, asincrónicas y escalables, integrando exportación a Excel, consumo de servicios externos y mensajería con RabbitMQ

## Criterios de Aceptación
- El API debe permitir CRUD de pacientes en una base de datos PostgreSQL usando R2DBC. Modelo(id, name, lastname, birthdate, sex, address, phone, email, created_at, updated_at)
- Todas las operaciones deben ser reactivas usando Reactor (Mono, Flux, map, flatMap, filter, switchIfEmpty, just, create, defer, zip, etc.).
- No se debe usar `.block()` en ningún punto del código.
- El manejo de hilos bloqueantes debe hacerse con `subscribeOn` (por ejemplo, para exportar pacientes a Excel usando Apache POI).
- El API debe exponer un endpoint para exportar los pacientes a un archivo Excel.
- Se debe consumir una API externa (WebClient) que retorne el estado del clima en Estados Unidos (url: https://api.open-meteo.com/v1/gfs?latitude=37.7749&longitude=-122.4194&hourly=temperature_2m,precipitation,wind_speed_10m&daily=temperature_2m_max,temperature_2m_min,precipitation_sum&current=temperature_2m,precipitation&forecast_days=3&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=America/Los_Angeles), mapeando la respuesta con Jackson y exponiéndola vía API.
- Al crear un paciente, se debe publicar el evento en una cola de RabbitMQ (usando una librería compatible con WebFlux).
- Debe existir un suscriptor reactivo a la cola de RabbitMQ que imprima el mensaje en consola, maneje el ack manualmente y realice reintentos en caso de fallo.
cuando se cree un paciente se debe publicar en una cola de rabbitmq (usar para esto una libreria apta para webflux)
y poner un suscriptor de dicha cola que lea el mensaje y simplemente lo imprima en consola
se debe manejar el ack de forma manual y en caso de fallo tener reintentos

- El manejo de errores debe contemplar onErrorResume, onErrorReturn y ControllerAdvice, diferenciando errores técnicos y de negocio.
- El sistema debe tener manejo de logs (error, info, debug, warn) usando Logback, y la solución ante errores de ejecución debe ser ajustar niveles de log, no solo agregar logs.
- El mapeo de errores de Jackson debe manejarse con try-catch y mapearse correctamente en Mono y Flux.

## Restricciones
- No se debe usar `.block()` bajo ninguna circunstancia.
- No se debe configurar Jenkins, Azure DevOps ni Sonar en el proyecto.
- El manejo de logs debe ser configurable por niveles y no por adición de logs en el código.
- El mapeo de objetos externos debe hacerse exclusivamente con Jackson.
- El manejo de errores debe ser explícito y diferenciado entre técnicos y de negocio.

## Notas
- La base de datos relacional debe ser PostgreSQL.
- Se debe practicar con varios operadores de Reactor (map, flatMap, filter, etc.).
- El exportador a Excel debe usar Apache POI y ejecutarse en hilos adecuados.
- El consumo de la API externa debe mapear la respuesta con Jackson y exponerla vía API.
- El suscriptor de RabbitMQ debe manejar el ack manualmente y soportar reintentos.
- El manejo de errores debe ser robusto y diferenciado.
- La calidad del código será validada localmente con SonarLint y plugins de coverage.

---

## Análisis y Diseño Arquitectónico (Arquitecto)

### 1. Contexto General
La historia 001 abarca la gestión completa de pacientes en una clínica, integrando:
- Persistencia reactiva en PostgreSQL (R2DBC)
- Exposición de API REST (Spring WebFlux)
- Publicación de eventos en RabbitMQ
- Exportación de pacientes a Excel (Apache POI, hilos bloqueantes)
- Consumo de API externa de clima (WebClient, Jackson)
- Manejo robusto de errores y logs

### 2. Componentes y Flujos Clave
- **API REST**: Controladores reactivos, sin uso de `.block()`
- **Servicio de Pacientes**: Orquestador de lógica, aplica validaciones, publica eventos, exporta Excel
- **Repositorio R2DBC**: Acceso a PostgreSQL de forma no bloqueante
- **RabbitMQ**: Publicador y suscriptor reactivo, ack manual y reintentos
- **Apache POI**: Exportación a Excel en hilo `boundedElastic`
- **WebClient**: Consumo de clima, mapeo con Jackson, manejo de errores
- **Logback**: Logging estructurado, niveles configurables

### 3. Diseño de Integración
- Los flujos de negocio documentados en `docs/architecture/flujo-registro-paciente.md`, `flujo-exportacion-excel.md` y `flujo-consulta-clima.md` se implementan como servicios independientes, reutilizables y desacoplados.
- El estándar de código en `coding-standards.md` es obligatorio para todos los módulos.
- El manejo de errores sigue el patrón: onErrorResume (técnicos), onErrorReturn (negocio), ControllerAdvice (HTTP).
- La exportación a Excel nunca debe bloquear el hilo principal; usar `subscribeOn(Schedulers.boundedElastic())`.
- El consumo de clima externo debe mapear errores de red/parsing y nunca usar `.block()`.
- El suscriptor de RabbitMQ debe manejar el ack manual y reintentos, logueando cada intento y error.

### 4. Decisiones Arquitectónicas
- **Reactividad total**: Todo el stack es no bloqueante salvo exportación Excel, que se aísla en hilo adecuado.
- **Separación de responsabilidades**: Cada flujo de negocio es un servicio dedicado.
- **Observabilidad**: Logs estructurados, métricas de éxito/fallo y tiempos de respuesta.
- **Pruebas**: Unitarias y de integración obligatorias, cobertura >80%.
- **Seguridad**: Validar datos de entrada, manejar errores sin exponer detalles internos.

### 5. Riesgos y Mitigaciones
- **Bloqueo accidental**: Revisar que ningún `.block()` llegue a producción.
- **Errores de integración**: Pruebas de integración y manejo robusto de errores.
- **Sobrecarga de hilos**: Limitar exportaciones concurrentes, usar `boundedElastic`.
- **Fallas en RabbitMQ**: Reintentos y logs claros para troubleshooting.

### 6. Referencias
- [flujo-registro-paciente.md](../architecture/flujo-registro-paciente.md)
- [flujo-exportacion-excel.md](../architecture/flujo-exportacion-excel.md)
- [flujo-consulta-clima.md](../architecture/flujo-consulta-clima.md)
- [coding-standards.md](../architecture/coding-standards.md)

---

## Refinamiento Técnico (Scrum Master)

### 1. Descomposición Técnica y Tareas
- Definir modelo de datos y entidades para paciente.
- Implementar repositorio R2DBC para operaciones CRUD.
- Crear servicios reactivos para lógica de negocio y validaciones.
- Desarrollar controladores REST (WebFlux) para exponer endpoints CRUD y exportación.
- Implementar exportación a Excel usando Apache POI en hilo `boundedElastic`.
- Configurar y consumir API externa de clima con WebClient y Jackson.
- Publicar eventos de creación de paciente en RabbitMQ (librería WebFlux compatible).
- Implementar suscriptor reactivo de RabbitMQ con ack manual y reintentos.
- Gestionar errores con onErrorResume, onErrorReturn y ControllerAdvice.
- Configurar logs con Logback y ajustar niveles según entorno.
- Escribir pruebas unitarias y de integración para todos los flujos.
- Validar cobertura de código (>80%) y reporte local.

### 2. Checklist de Refinamiento
- [ ] Modelo de paciente definido y validado
- [ ] Repositorio R2DBC implementado
- [ ] Servicios reactivos completos
- [ ] Endpoints REST documentados y funcionales
- [ ] Exportación a Excel funcional y no bloqueante
- [ ] Consumo de clima externo probado y mapeado
- [ ] Publicación y suscripción RabbitMQ reactiva
- [ ] Manejo de errores robusto y diferenciado
- [ ] Logs configurados y auditados
- [ ] Pruebas unitarias y de integración completas
- [ ] Cobertura de código validada localmente

### 3. Análisis de Riesgos Técnicos
- Uso incorrecto de `.block()` o hilos bloqueantes
- Errores de integración con servicios externos (clima, RabbitMQ)
- Pérdida de mensajes en RabbitMQ por mal manejo de ack/reintentos
- Exportación a Excel bloqueando el hilo principal
- Cobertura de pruebas insuficiente
- Logs excesivos o mal configurados

### 4. Contexto Técnico Complementario
- Seguir los estándares de `docs/architecture/coding-standards.md`.
- Reutilizar patrones y ejemplos de los flujos en `docs/architecture/`.
- Validar integración de todos los componentes antes de pasar a QA.
- Documentar endpoints y flujos en Swagger

---

## Estimación (Scrum Master)

### Estimación en Story Points
**13 puntos** (historia compleja, integración fullstack, múltiples tecnologías y pruebas)

### Justificación de la Estimación
- Incluye diseño e implementación de modelo, repositorio, servicios, controladores, exportación a Excel, integración con RabbitMQ y consumo de API externa.
- Requiere manejo avanzado de programación reactiva y pruebas de integración.
- Implica configuración y pruebas de logs, manejo de errores y cobertura >80%.
- Involucra riesgos técnicos por integración de múltiples tecnologías y manejo de hilos.

### Análisis de Complejidad
- **Tecnológica:** Alta (WebFlux, R2DBC, RabbitMQ, Apache POI, WebClient, Jackson)
- **Integración:** Alta (varios sistemas y flujos desacoplados)
- **Pruebas:** Alta (unitarias, integración, cobertura, manejo de errores)
- **Documentación:** Media (Swagger/OpenAPI, checklist, logs)

### Identificación de Riesgos
- Integración fallida entre componentes reactivos y bloqueantes
- Errores en manejo de hilos y concurrencia
- Pérdida de mensajes en RabbitMQ
- Cobertura de pruebas insuficiente
- Complejidad en manejo de errores y logs

---

**Estado:** Estimado (SM)
